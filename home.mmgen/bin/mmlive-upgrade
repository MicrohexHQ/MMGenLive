#!/bin/bash
# https://github.com/mmgen/MMGenLive/raw/master/home.mmgen/bin/mmlive-upgrade ->
# https://raw.githubusercontent.com/mmgen/MMGenLive/master/home.mmgen/bin/mmlive-upgrade

set -e

[ "$EUID" == 0 ] && { echo 'This script must be run as user, not as root'; exit 1; }
[ "$1" == '--reexec' ] && { shift; REEXEC=1; }

PROGNAME=$(basename $0)
CURL='curl -s -L'
PRIVOXY='http://localhost:8118'
URL_BASE='https://github.com/mmgen/MMGenLive/releases'
MMLIVE_REPO='https://github.com/mmgen/MMGenLive.git'
MMLIVE_REPO_DIR='/setup/git/MMGenLive'
REPO_UPGRADE_DIR="$MMLIVE_REPO_DIR/upgrade"
REPO_BIN_DIR="$MMLIVE_REPO_DIR/home.mmgen/bin"
PROJ_NAME='MMLiveUpgrade'
ONLINE=1
CURL='curl' GIT='git' APT_GET='apt-get' LYNX='lynx'

while getopts hgGp:sST OPT
do
	case "$OPT" in
	h)  printf "  %-16s Upgrade an MMGen installation\n" "${PROGNAME^^}:"
		echo   "  USAGE:           $PROGNAME"
		echo   "  OPTIONS:"
		echo   "    '-h'   Print this help message"
		echo   "    '-g'   Update git repository only; don't run upgrade scripts"
		echo   "    '-G'   Don't update git repository; run upgrade scripts only"
		echo   "    '-p h' Connect via proxy 'p' (protocol://host:port)"
		echo   "    '-s'   Skip authentication of commits"
		echo   "    '-S'   Skip verification of PGP signatures"
		echo   "    '-T'   Connect via Tor (through privoxy)"
		exit ;;
	g) GIT_UPDATE_ONLY=1 ;;
	G) ONLINE= ;;
	p) PROXY=$OPTARG
	   CURL="$CURL -x $OPTARG"
	   GIT="all_proxy=$OPTARG git"
	   APT_GET="https_proxy=$OPTARG http_proxy=$OPTARG apt-get"
	   LYNX="https_proxy=$OPTARG http_proxy=$OPTARG lynx" ;;
	s) SKIP_COMMIT_AUTH=1 ;;
	s) SKIP_PGP_VERIFY=1 ;;
	T) TOR='localhost:9050'
	   CURL="$CURL -x $PRIVOXY"
	   GIT="all_proxy=$PRIVOXY git"
	   APT_GET="https_proxy=$PRIVOXY http_proxy=$PRIVOXY apt-get"
	   LYNX="https_proxy=$PRIVOXY http_proxy=$PRIVOXY lynx" ;;
	*) exit ;;
	esac
done

ARGV="$@"
shift $((OPTIND-1))

export ONLINE CURL GIT APT_GET LYNX
[ "$REEXEC" ] || {
	[ "$PROXY" ] && echo "Connecting via proxy $PROXY"
	[ "$TOR" ] && echo "Connecting via Tor ($TOR) over privoxy ($PRIVOXY)"
}

. ~/scripts/include/functions.sh

function gpg_verify() {
	[ "$SKIP_PGP_VERIFY" ] && return 0
	echo -n "Verifying signature on '$2'..."
	set +e
	out=$($GPG --verify $1 $2 2>/dev/null) # 1:signature 2:signed file
	[ $? == 0 ] || { echo 'FAILED'; exit; }
	set -e
	echo "OK"
}

function init_vars {
	MY_VER=$(cat $HOME/var/version)
	DIR="$HOME/var/$MY_VER"

	if [ ! -d "$DIR" ]; then
		mkdir -p "$DIR"
		FILES="$(ls $HOME/var/upgrade* $HOME/var/revision* 2>/dev/null)"
		[ "$FILES" ] && { echo 'Relocating revision and upgrade files'; mv -f $FILES $DIR; }
		mv $DIR/revision $DIR/revision.my || true
		mv $DIR/revision.cur $DIR/revision || true
		mv $DIR/revision.cur.sig $DIR/revision.sig || true
	fi

	MY_REV=$(cat $DIR/revision.my)
	[ "$REEXEC" ] || gmsg "Version $MY_VER, revision '$MY_REV'"

	URL="$URL_BASE/download/revisions-v$MY_VER"
	REVS='0abcdefghijklmnopqrstuvwxyz'
	GPG='gpg --quiet --trust-model always'
}

function git_update {
	echo 'Updating MMGenLive git repository'
	cd $MMLIVE_REPO_DIR
	[ -d '.git' ] || eval "$GIT clone $MMLIVE_REPO ."
	cur_branch=$(git branch --color=never | grep '*' | awk '{ print $2 }')
	git checkout -q master
	eval "$GIT pull --no-edit --force --strategy=recursive --strategy-option=theirs"
	LAST_COMMIT=$(git log --oneline --color=never --no-merges --pretty=%h | head -n1)
	[ "$SKIP_COMMIT_AUTH" ] || {
		git verify-commit $LAST_COMMIT 2>/dev/null || {
			echo 'Unable to verify latest commit. Aborting'
			exit 1
		}
		echo 'Signature on latest commit OK'
	}
	git checkout -q $cur_branch
}

function offline_upgrade {
	cd $REPO_UPGRADE_DIR
	ver=$(cat version)
	if [ "$ver" != "$MY_VER" ]; then
		yecho "Your version of MMGenLive ($MY_VER) is outdated!"
		yecho "Please download the latest version ($ver) from the MMGenLive project page"
	fi
	scripts=$(for s in $MY_VER/upgrade-?.sh; do s=${s#*upgrade-} s=${s%.sh}; echo -n " $s"; done)
	printf "Target revision: '%s'\n" $(echo $scripts | sed 's/.* //')
	for s in $scripts; do
		if [ $s '>' $MY_REV ]; then
			script="$MY_VER/upgrade-$s.sh"
			echo "Executing '$script'"
			set +e
			bash $script || { recho "Execution of script '$script' failed"; exit; }
			set -e
			echo $s > "$DIR/revision.my"
			MY_REV=$(cat $DIR/revision.my)
			bmsg "Upgraded to revision '$MY_REV'"
		fi
	done
	echo 'System is up-to-date'
}

init_vars
[ "$ONLINE" -a -d "$MMLIVE_REPO_DIR" -a ! "$REEXEC" ] && {
	git_update
	# script may have changed, so re-exec with original args, skipping git update
	exec $0 --reexec $ARGV
}
[ "$GIT_UPDATE_ONLY" ] || offline_upgrade
